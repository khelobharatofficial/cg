<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chhattisgarh Map — District</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <!-- D3 & TopoJSON -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"
          crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>

  <!-- Export libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"
          crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
          crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <style>
    *{box-sizing:border-box}
    body{
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;
      background:#f4f6fb;margin:0;color:#111;
    }
    .container{max-width:1200px;margin:18px auto;padding:16px}
    .layout{display:grid;grid-template-columns:minmax(260px,360px) 1fr;gap:16px}
    @media (max-width:900px){.layout{grid-template-columns:1fr}}
    .card{background:#fff;border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(10,20,50,0.06)}
    h1{margin:0 0 8px;font-size:22px}
    label{display:block;font-weight:600;margin:8px 0 4px;font-size:0.95rem}
    input[type="text"],select{width:100%;padding:8px;border-radius:6px;border:1px solid #d1d7e0;font-size:0.95rem}
    .row{display:flex;gap:8px;align-items:center;margin-bottom:8px}
    .row select{flex:1}
    .row input[type="color"]{width:44px;height:34px;padding:0;border:none}
    .row .data-input{width:150px;min-width:120px}
    button{background:#2563eb;color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer;font-weight:700}
    button.secondary{background:#0f766e;margin-left:6px}
    button:disabled{opacity:.6;cursor:not-allowed}
    .small{font-size:0.82rem;color:#666;margin-top:6px}
    #map-wrap{background:#f8fafc;border-radius:8px;padding:8px;border:1px solid #e6eef6}
    #map-area{min-height:520px;border-radius:6px;background:#fff;padding:8px;display:flex;align-items:center;justify-content:center;position:relative}
    svg{width:100%;height:auto;display:block}
    #data-box{margin-top:10px;padding:10px;border-radius:8px;background:#f1f5f9;border:1px solid #e2e8f0}
    .label-bg { fill:#ffffff; stroke:#e2e8f0; stroke-width:0.8px; rx:6px; ry:6px; }
    .label-name { font-size:12px; font-weight:700; fill:#071022; }
    .label-value { font-size:12px; fill:#071022; opacity:0.9; }
    footer{margin-top:18px;text-align:center;color:#555}
  </style>
</head>
<body>
  <div class="container">
    <header style="display:flex; align-items:center; gap:14px; margin-bottom:8px;">
      <a href="#" style="display:inline-block;" title="Khelo Bharat Officials">
        <img src="favicon.svg" alt="Khelo Bharat" style="height:56px; width:auto; display:block;">
      </a>
      <div>
        <h1 style="margin:0; font-size:22px;">Chhattisgarh Map — District</h1>
        <p class="small" style="margin:6px 0 0;">
          Labels will appear in tidy columns on either side of the map. The data list prints below the map as 'District — value'.
        </p>
      </div>
    </header>

    <div class="layout">
      <!-- Controls -->
      <div class="card">
        <label for="mapTitle">Map title</label>
        <input id="mapTitle" type="text" placeholder="e.g. Vaccination by District" />

        <label for="numDistricts">Number of districts to colour & attach data</label>
        <select id="numDistricts">
          <option value="0">0</option>
          <!-- up to 20 -->
          <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
          <option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
          <option>11</option><option>12</option><option>13</option><option>14</option><option>15</option>
          <option>16</option><option>17</option><option>18</option><option>19</option><option>20</option>
        </select>

        <div class="small">Each row: district, colour and the data text (e.g. "11145").</div>

        <div id="district-selectors" style="margin-top:10px"></div>

        <hr style="margin:12px 0;border:none;border-top:1px solid #eef2f7" />

        <label for="dataTitle">Title of data (appears below map)</label>
        <input id="dataTitle" type="text" placeholder="e.g. Vaccination Rate (2025)" />

        <div style="margin-top:10px">
          <button id="generateBtn">Generate Map</button>
          <span id="status" class="small" style="margin-left:10px"></span>
        </div>

        <hr style="margin:12px 0;border:none;border-top:1px solid #eef2f7" />

        <div>
          <button id="downloadPng" class="secondary" disabled>Download PNG</button>
          <button id="downloadPdf" class="secondary" disabled>Download PDF</button>
          <div class="small" style="margin-top:6px">Export buttons enable after generating the map.</div>
        </div>
      </div>

      <!-- Preview -->
      <div class="card">
        <div id="map-wrap">
          <div id="map-area">
            <span class="small">Map will appear here after you click Generate Map.</span>
          </div>
          <div id="data-box">
            <h3 id="dataTitleDisplay">Data title will appear here</h3>
            <div id="dataList" class="small" style="margin-top:8px">Selected district data will list here as 'District — value'.</div>
          </div>
        </div>
      </div>
    </div>

    <footer>© 2025 <strong>Khelo Bharat Officials</strong>.</footer>
  </div>

  <script>
    // Globals
    let topo = null;
    let features = [];
    let districtNames = [];
    const objectKey = "districts"; // object name in chhattisgarh.json
    const nameProp = "district";   // property name for district name

    const statusEl = document.getElementById("status");

    // Load TopoJSON
    fetch("chhattisgarh.json")
      .then(r => {
        if (!r.ok) throw new Error("Failed to load chhattisgarh.json — put it in same folder.");
        return r.json();
      })
      .then(t => {
        topo = t;
        if (!t.objects || !t.objects[objectKey]) {
          throw new Error("chhattisgarh.json missing object named 'districts'.");
        }
        const geo = topojson.feature(t, t.objects[objectKey]);
        features = geo.features || [];
        const set = new Set();
        features.forEach(f => {
          const nm = (f.properties && f.properties[nameProp]) || f.id || "Unknown";
          set.add(nm);
        });
        districtNames = Array.from(set).sort((a,b)=>a.localeCompare(b));
        buildSelectors(0);
        statusEl.textContent = `Loaded ${districtNames.length} districts.`;
      })
      .catch(err => {
        console.error(err);
        statusEl.textContent = err.message;
      });

    // Create selector rows
    function buildSelectors(count){
      const container = document.getElementById("district-selectors");
      container.innerHTML = "";
      for(let i=0;i<count;i++){
        const row = document.createElement("div");
        row.className = "row";

        const label = document.createElement("div");
        label.style.minWidth="40px";
        label.style.fontWeight="600";
        label.style.fontSize="0.9rem";
        label.textContent = `#${i+1}`;

        const sel = document.createElement("select");
        sel.className = "district-select";
        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "-- select district --";
        sel.appendChild(defaultOpt);
        districtNames.forEach(n=>{
          const o = document.createElement("option");
          o.value = n; o.textContent = n;
          sel.appendChild(o);
        });

        const color = document.createElement("input");
        color.type = "color";
        color.className = "district-color";
        color.value = "#2563eb";

        const dataInput = document.createElement("input");
        dataInput.type = "text";
        dataInput.placeholder = "value (e.g. 11145)";
        dataInput.className = "data-input district-data";

        row.appendChild(label);
        row.appendChild(sel);
        row.appendChild(color);
        row.appendChild(dataInput);
        container.appendChild(row);
      }
    }

    document.getElementById("numDistricts").addEventListener("change", e=>{
      const c = parseInt(e.target.value) || 0;
      buildSelectors(c);
    });

    // Read mappings and prepare data list
    function getMappings(){
      const mapping = {}; // district -> color
      const dataMap = {}; // district -> text
      const sels = document.querySelectorAll(".district-select");
      const cols = document.querySelectorAll(".district-color");
      const datas = document.querySelectorAll(".district-data");
      sels.forEach((s,i)=>{
        const name = s.value;
        const color = (cols[i] && cols[i].value) || "#000000";
        const dataText = (datas[i] && datas[i].value) || "";
        if(name){
          mapping[name] = color;
          dataMap[name] = dataText;
        }
      });
      return { mapping, dataMap };
    }

    function featureName(f){
      return (f.properties && f.properties[nameProp]) || f.id || "Unknown";
    }

    // compute centroids (projected)
    function computeCentroids(projection){
      const centroids = {};
      features.forEach(f => {
        const centroid = d3.geoCentroid(f);
        const p = projection(centroid);
        centroids[featureName(f)] = p;
      });
      return centroids;
    }

    // helper: split user data string into lines
    function splitDataLines(text){
      if(!text) return [];
      // preserve explicit newlines
      if(text.includes('\n')) return text.split('\n').map(s=>s.trim()).filter(Boolean);

      // split on common separators
      const sepMatch = /[|;,:]+/;
      if(sepMatch.test(text)){
        return text.split(sepMatch).map(s=>s.trim()).filter(Boolean);
      }

      // try to match segments that end with a number (works for "कार्यक्रम 7 संख्या 400 ...")
      const re = /[^0-9\n]+?\d+/gu;
      const segs = text.match(re);
      if(segs && segs.length){
        return segs.map(s=>s.trim());
      }

      // fallback: wrap into short lines (~28 chars) by words
      const words = text.split(/\s+/).filter(Boolean);
      const lines = [];
      let line = "";
      for(const w of words){
        if((line + ' ' + w).trim().length > 28){
          if(line) lines.push(line.trim());
          line = w;
        } else {
          line = (line + ' ' + w).trim();
        }
      }
      if(line) lines.push(line.trim());
      return lines;
    }

    // draw map with labels only on left/right columns
    function draw(){
      if(!features.length){ alert("TopoJSON not loaded yet."); return; }

      const mapTitle = document.getElementById("mapTitle").value.trim();
      const dataTitle = document.getElementById("dataTitle").value.trim();
      document.getElementById("dataTitleDisplay").textContent = dataTitle || "No data title given";

      const { mapping, dataMap } = getMappings();

      // build data list in the data-box (District — value) with multi-line support
      const dataListEl = document.getElementById("dataList");
      dataListEl.innerHTML = "";
      const orderedNames = Object.keys(mapping);
      if(orderedNames.length === 0){
        dataListEl.textContent = "Selected district data will list here as 'District — value'.";
      } else {
        const container = document.createElement("div");
        container.style.display = "flex";
        container.style.flexDirection = "column";
        container.style.gap = "10px";

        orderedNames.forEach(n => {
          const raw = dataMap[n] || "";
          const lines = splitDataLines(raw);

          // each entry: district name as title, then lines beneath
          const entry = document.createElement("div");
          entry.style.display = "flex";
          entry.style.flexDirection = "column";
          entry.style.gap = "4px";

          const title = document.createElement("div");
          title.textContent = n + (lines.length ? " —" : "");
          title.style.fontWeight = "700";
          entry.appendChild(title);

          if(lines.length){
            const linesWrap = document.createElement("div");
            linesWrap.style.display = "flex";
            linesWrap.style.flexDirection = "column";
            linesWrap.style.marginLeft = "6px";
            lines.forEach(lineText => {
              const lineDiv = document.createElement("div");
              lineDiv.textContent = lineText;
              lineDiv.style.fontWeight = "600";
              linesWrap.appendChild(lineDiv);
            });
            entry.appendChild(linesWrap);
          }

          container.appendChild(entry);
        });

        dataListEl.appendChild(container);
      }

      // render SVG map
      const wrap = d3.select("#map-area");
      wrap.selectAll("*").remove();

      const width = 920;
      const height = 700;
      const svg = wrap.append("svg")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio","xMidYMid meet");

      if(mapTitle){
        svg.append("text")
          .attr("x", width/2)
          .attr("y", 30)
          .attr("text-anchor","middle")
          .attr("font-size",20)
          .attr("font-weight",700)
          .text(mapTitle);
      }

      const g = svg.append("g")
        .attr("transform", mapTitle ? "translate(0,44)" : "translate(0,10)");

      const innerW = width;
      const innerH = height - 60;

      const projection = d3.geoMercator()
        .fitSize([innerW, innerH], { type:"FeatureCollection", features });

      const path = d3.geoPath().projection(projection);

      // fill districts
      g.selectAll("path.district")
        .data(features)
        .join("path")
        .attr("class","district")
        .attr("d", path)
        .attr("fill", d => mapping[featureName(d)] || "#ffffff")
        .attr("stroke","none");

      // draw outer & internal borders
      if(topo && topo.objects && topo.objects[objectKey]){
        const obj = topo.objects[objectKey];
        const outer = topojson.mesh(topo, obj, (a,b) => a === b);
        g.append("path").attr("d", path(outer)).attr("fill","none").attr("stroke","#0f1724").attr("stroke-width",1.1);
        const internal = topojson.mesh(topo, obj, (a,b) =>
          a !== b && a.properties && b.properties && a.properties[nameProp] !== b.properties[nameProp]
        );
        g.append("path").attr("d", path(internal)).attr("fill","none").attr("stroke","#0f1724").attr("stroke-width",0.6);
      }

      // bounding box of map in SVG coords
      const bounds = path.bounds({ type:"FeatureCollection", features });
      const minX = bounds[0][0], minY = bounds[0][1];
      const maxX = bounds[1][0], maxY = bounds[1][1];

      // compute centroids
      const centroids = computeCentroids(projection);

      // split selected items into left and right by centroid x
      const centerX = (minX + maxX) / 2;
      const selected = Object.keys(mapping);
      const leftItems = [], rightItems = [];
      selected.forEach(name => {
        const c = centroids[name];
        if(!c) return;
        if (c[0] < centerX) leftItems.push({name, centroid: c, color: mapping[name], value: dataMap[name]});
        else rightItems.push({name, centroid: c, color: mapping[name], value: dataMap[name]});
      });

      // decide label column X positions (inside SVG viewport)
      const colPad = 34;          // distance from map bbox
      const colLeftX = Math.max(8, minX - colPad - 180);   // label column left (ensure not off-viewport)
      const colRightX = Math.min(innerW - 8 - 180, maxX + colPad); // label column right

      // available Y range for stacking labels (within projected map vertical bounds)
      const topY = Math.max(6, minY - 10);
      const bottomY = Math.min(innerH - 6, maxY + 10);

      // helper to assign Y positions evenly for N items within topY..bottomY
      function computeYPositions(n){
        const ys = [];
        if(n === 0) return ys;
        const space = (bottomY - topY) / (n + 1);
        for(let i=1;i<=n;i++){
          ys.push(topY + i * space);
        }
        return ys;
      }

      const leftYs = computeYPositions(leftItems.length);
      const rightYs = computeYPositions(rightItems.length);

      // draw callouts: lines from centroid -> labelX,labelY; label box at labelX,labelY
      const labelGroup = g.append("g").attr("class","callouts");

      // helper to render one label (multiline support inside svg)
      function renderLabel(labelX, labelY, item, anchor) {
        // split lines for the item.value
        const dataLines = splitDataLines(item.value || "");

        // measure text widths approximately (use character count)
        // prepare combined lines (title + lines) to estimate width
        const titleText = item.name;
        const candidateLines = dataLines.length ? [titleText, ...dataLines] : [titleText];
        let maxLen = 0;
        candidateLines.forEach(s => { if(s.length > maxLen) maxLen = s.length; });
        const estWidth = Math.min(320, Math.max(80, Math.round(maxLen * 7))); // estimate char width 7px

        const boxPadX = 8, boxPadY = 6;
        const lineHeight = 14; // pixels between lines
        const titleHeight = 14;
        const dataHeight = dataLines.length ? (dataLines.length * lineHeight) : 0;
        const boxHeight = titleHeight + dataHeight + boxPadY*2 + (dataLines.length ? 6 : 0);

        // leader line
        labelGroup.append("line")
          .attr("x1", item.centroid[0])
          .attr("y1", item.centroid[1])
          .attr("x2", labelX)
          .attr("y2", labelY)
          .attr("stroke", item.color)
          .attr("stroke-width", 2)
          .attr("stroke-linecap", "round");

        // position box depending on anchor
        let boxX = anchor === "left" ? labelX - estWidth - 10 : labelX + 10;
        let boxY = labelY - (boxHeight / 2);

        // clamp inside viewport
        boxX = Math.max(6, Math.min(innerW - estWidth - boxPadX*2 - 6, boxX));
        boxY = Math.max(6, Math.min(innerH - boxHeight - 6, boxY));

        // background rect
        labelGroup.append("rect")
          .attr("x", boxX - boxPadX)
          .attr("y", boxY - boxPadY)
          .attr("width", estWidth + boxPadX*2)
          .attr("height", boxHeight)
          .attr("class","label-bg")
          .attr("rx",6).attr("ry",6)
          .attr("fill","#fff").attr("stroke","#e2e8f0");

        // text group
        const tx = labelGroup.append("text")
          .attr("x", boxX)
          .attr("y", boxY + 10)
          .attr("class","label-name");

        // title (district name)
        tx.append("tspan")
          .attr("x", boxX)
          .attr("dy", 0)
          .text(titleText);

        // data lines (if any) using smaller style (simulate .label-value)
        if(dataLines.length){
          dataLines.forEach((ln, idx) => {
            tx.append("tspan")
              .attr("x", boxX)
              .attr("dy", idx === 0 ? lineHeight : lineHeight) // move down for each tspan
              .attr("class", "label-value")
              .text(ln);
          });
        }
      }

      // render left column (sorted top->bottom by centroid y to keep visual order)
      leftItems.sort((a,b)=>a.centroid[1]-b.centroid[1]);
      leftItems.forEach((it, idx) => {
        const y = leftYs[idx] || (topY + idx * 18);
        const anchorPointX = colLeftX;
        renderLabel(anchorPointX, y, it, "left");
      });

      // render right column
      rightItems.sort((a,b)=>a.centroid[1]-b.centroid[1]);
      rightItems.forEach((it, idx) => {
        const y = rightYs[idx] || (topY + idx * 18);
        const anchorPointX = colRightX;
        renderLabel(anchorPointX, y, it, "right");
      });

      // enable exports
      document.getElementById("downloadPng").disabled = false;
      document.getElementById("downloadPdf").disabled = false;
      statusEl.textContent = "Map generated. Labels placed in left/right columns and data listed below.";
    }

    document.getElementById("generateBtn").addEventListener("click", draw);

    // Export helpers
    async function downloadPNG(){
      const area = document.getElementById("map-wrap");
      const canvas = await html2canvas(area, {scale:2});
      const link = document.createElement("a");
      link.download = "chhattisgarh-map-callouts.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    }
    async function downloadPDF(){
      const area = document.getElementById("map-wrap");
      const canvas = await html2canvas(area, {scale:2});
      const img = canvas.toDataURL("image/png");
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF("p","mm","a4");
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const imgProps = pdf.getImageProperties(img);
      const pdfW = pageW - 12;
      const pdfH = imgProps.height * pdfW / imgProps.width;
      const y = Math.max((pageH - pdfH)/2, 8);
      pdf.addImage(img,"PNG",6,y,pdfW,pdfH);
      pdf.save("chhattisgarh-map-callouts.pdf");
    }

    document.getElementById("downloadPng").addEventListener("click", downloadPNG);
    document.getElementById("downloadPdf").addEventListener("click", downloadPDF);
  </script>
</body>
</html>
